"
""note that there is no binding between this function and rest of heysql, so can tables
	in practice be done from pure sql code as well.
	
	Dictionary should be oncreateTableCellButtonUsing: 
	colors := Dictionary personDict { 
	   'id' -> 'serial' . 
	   'forname' -> 'textt' . 
	   'surname' -> 'json' 
	}. 

	All P3-types can be used, look them up for a complete list
"
Class {
	#name : #HeySql,
	#superclass : #Object,
	#instVars : [
		'id'
	],
	#classVars : [
		'DbFields',
		'DbFieldsLowercased',
		'Pool',
		'Statements',
		'Url'
	],
	#category : #'HeySql-Initialize'
}

{ #category : #db }
HeySql class >> closePool [
	Pool close.
	


]

{ #category : #initialization }
HeySql class >> createTable: tableName tableDict: tableDict [
	"helper function to quick create table based on a heysql instance
        note that there is no binding between this function and rest of heysql, so can tables
        in practice be done from pure sql code as well.
        
        Dictionary should be oncreateTableCellButtonUsing:
        personDict := Dictionary newFrom { 
           'id' -> 'serial' .
           'forname' -> 'textt' . 
           'surname' -> 'json' 
        }.

        All P3-types can be used, look them up for a complete list"

	| sqlString |
	sqlString := 'create table {1} (' format: {tableName}.
	tableDict
		keysAndValuesDo: [ :fieldName :fieldType | 
			sqlString := sqlString , '{1} {2},'
				format:
					{fieldName.
					fieldType} ].
	Pool withConnection: [ :client |	client execute: sqlString allButLast , ')' ].
]

{ #category : #accessing }
HeySql class >> dbFields [
	"returns the fields to be handled by heysql as a string. If the dbFields: function is not called, we use all instance variables from the class, including superclasses of type heysql"

	| key |
	key := self asString.
	(DbFields includesKey: key)
		ifFalse: [ | classes dbfields |
			classes := self allSuperclasses
				select: [ :c | c respondsTo: #dbFields ].
			dbfields := classes , {self}
				flatCollect: [ :c | 
					(DbFields includesKey: c asString)
						ifTrue: [ DbFields at: c asString ]
						ifFalse: [ c instVarNames collect: [ :v | v asString ] ] ].
			dbfields := dbfields asSet asSortedCollection.
			dbfields remove: 'id'.
			DbFields at: key put: dbfields ].
	^ DbFields at: key
]

{ #category : #accessing }
HeySql class >> dbFields: allFields [
	"Set fields which also have column in database"

	| fields |
	fields := (allFields splitOn: ' ') asSet.
	DbFields at: self asString put: fields asArray.
	self generateGettersAndSetters
]

{ #category : #'private ' }
HeySql class >> dbFieldsLc: dbLc theClass: theClass [
	"translates between lower case results in pg and method names with upper case. populates class lazyly"

	(DbFieldsLowercased includesKey: theClass)
		ifFalse: [ (DbFields at: theClass)
				do: [ :key | DbFieldsLowercased at: key asLowercase put: key ].
				DbFieldsLowercased at: 'id' put: 'id' ].
	^ DbFieldsLowercased at: dbLc
]

{ #category : #'private ' }
HeySql class >> executePreparedStatementSafe: statementName values: values [
	"executes a prepared statment, generates missing statments if not found"
	| statement |		
	Pool withConnection: [ :client | 
			[ statement := client preparedStatementNamed: statementName.
			  ^ statement query: values ]
		   on: NotFound do: [ 
				self prepareStatements: client. 
				statement := client preparedStatementNamed: statementName.
			   ^ statement query: values
		 ]].

]

{ #category : #'private ' }
HeySql class >> findNumberOfParams: sql [
	"Iterates over a P3-executable and finds number of sql-params, namely those who starts with $"

	| s |
	s := Set new.
	sql regex: '[$]\d+' matchesCollect: [ :r | s add: r ]. 
	^ s size
]

{ #category : #initialization }
HeySql class >> generateGettersAndSetters [
	"Generete getters and setters for all db-fields. Db-fields should allready be set with DbFields"

	| theObject |
	self dbFields
		do: [ :field | 
			| getter setter |
			getter := '
	    {1} 
	    "Autogenerated HeySql getter"
	    ^{1}.
	  ' format: {field}.
			setter := '
	    {1}: x  
	    "Autogenerated HeySql setter"
	    {1} := x.
		 ^ x.
	  ' format: {field}.
			theObject := self new.
			(theObject respondsTo: (field asSymbol))
				ifFalse: [ self compile: getter classified: 'accessor' ].
			(theObject respondsTo: (field, ':') asSymbol)
				ifFalse: [ self compile: setter classified: 'accessor' ] ]
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationInsert: tableName [
	"Generate methods for inserting and updating. Before running this method setDbFiels must have been called"

	| sqlInsert fields values |
	fields := self dbFields joinUsing: ','.
	values := (Interval from: 1 to: self dbFields size)
		collect: [ :i | '$' , i asString ].
	sqlInsert := 'insert into {1}({2}) values({3}) returning id'
		format:
			{tableName.
			fields.
			(values joinUsing: ',')}.
	Statements at: 'heysql_insert_' , tableName put: sqlInsert
]

{ #category : #'private ' }
HeySql class >> generateSimpleDbOperationUpdate: tableName [
	"generate update statment and method on object"

	| sqlUpdate fields values updateFields |
	fields := self dbFields select: [ :f | f ~~ 'id' ].
	values := (Interval from: 1 to: self dbFields size)
		collect: [ :i | '$' , i asString ].
	updateFields := fields with: values collect: [ :f :v | f , '=' , v ].
	sqlUpdate := 'update {1} set {2} where id = {3}'
		format:
			{tableName.
			(updateFields joinUsing: ', ').
			('$' , (fields size + 1) asString)}.
	Statements at: 'heysql_update_' , tableName put: sqlUpdate
]

{ #category : #initialization }
HeySql class >> generateSimpleDbOperations: tableName [
	"generate insert and update statemens and methods for the object. setDbFields must have been done before doing this."

	self generateSimpleDbOperationInsert: tableName.
	self generateSimpleDbOperationUpdate: tableName
]

{ #category : #initialization }
HeySql class >> generateSqlMethods: dict [
	"Iterating over all key-value elements in a dictionary and creates methods based on these. It is based on P3-postgres syntax.
	 sql-functions with parameter need to be declared ending with colon, like always in smalltalk "

	"Example: 
	
	d := Dictionary newFrom: 
	{ 'allBooks' -> 'select * from books' . 
  	  'allCustomerWithMoreThanOnePurches' -> 'select, join and have sql-fun here' 
	  'queryWithTwoParamsParam1, param2' -> 'select something where x = $1 and y = $2 ]  ' 
	}. 
	
	"

	dict
		keysAndValuesDo: [ :methodNames :sql | 
			"self class compile: methodString classified: 'heysql' ]"
			| methodString numParamsInSql params methodNameMaybeParams executeParams allMethods methodNameStatement |
			methodNameStatement := methodNames , '_' , self asString.
			self generateSqlStatement: methodNames sql: sql.
			numParamsInSql := self findNumberOfParams: sql.
			params := numParamsInSql > 0
				ifTrue: [ (Interval from: 1 to: numParamsInSql)
						collect: [ :v | 'p' , v asString ] ]
				ifFalse: [ #() ].
			methodNameMaybeParams := numParamsInSql > 0
				ifTrue: [ allMethods := (methodNames splitOn: ',') collect: [ :s | s , ': ' ].
					(allMethods with: params collect: [ :s1 :s2 | s1 , s2 ])
						joinUsing: ' ' ]
				ifFalse: methodNames.
			executeParams := '{ ' , (params joinUsing: '. ') , ' }'.
			methodString := '
	     {1} 
	     "Autogenerated heysql-method"
	     | result |
	     result := self executePreparedStatementSafe: ''{3}'' values: {2}.
	     ^ (self toObject: result).
	    '
				format:
					{methodNameMaybeParams.
					executeParams.
					methodNameStatement}.
			self class compile: methodString classified: 'accessor' ]
]

{ #category : #'private ' }
HeySql class >> generateSqlStatement: methodName sql: sql [
	"Add an server side compiled statment which can be access from a slot"

	Statements at: methodName , '_' , self asString put: sql
]

{ #category : #db }
HeySql class >> getPool [
	^ Pool

]

{ #category : #initialization }
HeySql class >> init: url [
	"init start variables"

	Statements := Dictionary new.
	DbFields := Dictionary new.
	DbFieldsLowercased := Dictionary new.
	Pool := P3ConnectionPool url: url.
	self url: url.
	Pool configurator: [ :client | self prepareStatements: client ]
]

{ #category : #db }
HeySql class >> packageDbSetup: packageName [
	"Iterates over all classes in a package and calls dbSetup method on the method if found"

	| classes |
	classes := Smalltalk allClassesAndTraits
		select: [ :theClass | 
			| className |
			className := theClass category asString.
			(className beginsWith: packageName)
				& ((className findString: 'Manifest') = 0) ].
	classes
		do: [ :theClass | 
			Transcript show: theClass.
			theClass generateGettersAndSetters.
			theClass
				generateSimpleDbOperations:
					(theClass
						asString)
						asLowercase.
			(theClass respondsTo: #dbSetup)
				ifTrue: [ theClass dbSetup ] ]
]

{ #category : #accessing }
HeySql class >> pool: anObject [
	Pool := anObject
]

{ #category : #db }
HeySql class >> prepareStatements: client [
	"prepare statments for a new connection."

	self assert: client isWorking.
	Statements
		keysAndValuesDo:
			[ :statementName :sql | | statement |
			[  statement := client preparedStatementNamed: statementName.
			 	statement close.
			 ] on: Error do: [ nil ].
			client prepare: sql named: statementName ]
]

{ #category : #accessing }
HeySql class >> statements [
	^ Statements
]

{ #category : #accessing }
HeySql class >> statements: anObject [
	Statements := anObject
]

{ #category : #'private ' }
HeySql class >> toObject: rSet [
	"Convert P3-result to an object. This is done by reflecion - iterating over all fields."

	| methodFields manyObjects res theClassStr |
	methodFields := rSet data
		collect: [ :row | 
			(rSet descriptions collect: [ :f | f fieldName ])
				with: row
				collect: [ :f1 :f2 | 
					{f1.
					f2} ] ].
	theClassStr := self asString.
	manyObjects := methodFields
		collect: [ :row | 
			| obj |
			obj := self new.
			row
				do: [ :field | 
					obj
						perform: ((self dbFieldsLc: field first theClass: theClassStr ) , ':') asSymbol
						withArguments: {field second} ].
			obj ].
	manyObjects isEmpty
		ifTrue: [ ^ nil ].
	res := manyObjects size > 1
		ifTrue: [ manyObjects ]
		ifFalse: [ manyObjects first ].
	^ res
]

{ #category : #accessing }
HeySql class >> url [
	^ Url
]

{ #category : #accessing }
HeySql class >> url: anObject [
	Url := anObject
]

{ #category : #db }
HeySql >> getTableName [
	^ self className .
]

{ #category : #accessor }
HeySql >> id [ 
	    "Autogenerated HeySql getter"
	    ^id.
	  
]

{ #category : #accessor }
HeySql >> id: x [  
	    "Autogenerated HeySql setter"
	    id := x.
	  
]

{ #category : #db }
HeySql >> insert [
	"HeySql autogenerated method for inserting objects"

	| values res newId statementName statement |
	values := self class dbFields
		collect: [ :field | self perform: field asSymbol ].
	statementName := 'heysql_insert_' , self className.
	(Statements includesKey: statementName)
		ifFalse: [ self class generateSimpleDbOperations: self getTableName ].
	Pool withConnection: [ :client | 
			[ statement := client preparedStatementNamed: statementName.
			  res := statement query: values.
			  newId := (res data at: 1) at: 1 .
			  self id: newId.  
			  ^ res.
			]
		   on: NotFound do: [ 
				self class generateSimpleDbOperations: self getTableName.
				self class prepareStatements: client. 
				statement := client preparedStatementNamed: statementName.
			   res := statement query: values.
			   newId := (res data at: 1) at: 1 .
			   self id: newId.  
			   ^ res.
		 ]].
]

{ #category : #documenting }
HeySql >> notes [
	" 
	TEST
	myDict keysAndValuesDo: [ :key :value | value doSomething ].
	Dictionary newFrom: {1 -> 7. 2 -> 3. 3 -> 1. 4 -> 3}
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	(Smalltalk classNamed: clsName) methodName: arg. (maybe param, but check more params) 
	
	Transcript show: o class asString.
	
	'HeySql' asClass .
	
	s := Set new.
'this is {1} and {2}' regex: '{\d+}' matchesCollect: [ :r |
	s add: r].
s size.
	
	5 perform: ('factorial' asSymbol ) og 4 perform: #max: withArguments
	
!! Encode

x := (ZnCharacterEncoder newForEncoding: 'utf8')
      encodeString: 'Les élèves Français'.

(ZnCharacterEncoder newForEncoding: 'utf8') decodeBytes: x		
	
	"

	
]

{ #category : #db }
HeySql >> update [
	"HeySql autogenerated method for inserting objects"

	| values fields statementName statement |
	fields := self class dbFields.
	values := fields collect: [ :field | self perform: field asSymbol ].
	statementName := 'heysql_update_' , self className.
	Pool
		withConnection: [ :client | 
			[ statement := client preparedStatementNamed: statementName.
			  ^ statement query: values , {id} ]
		   on: NotFound do: [ 
				self class generateSimpleDbOperations: self getTableName.
				self class prepareStatements: client. 
				statement := client preparedStatementNamed: statementName.
			   ^ statement query: values , {id}
		 ]]. 

]
